{"pages":[{"title":"friends","text":"","link":"/friends/index.html"},{"title":"关于俺的一点点碎碎念","text":"哈喽，大家好，欢迎来到弗蕾西！ 先说一下搭建这个博客的初衷：主要是想要在互联网上留下一些属于自己的印记，所以博客会以学习记录为主。最主要的还是记录学习过程中遇到的一些困难以及怎样解决它们的亦或是总结知识点、记录学习收获这类内容。反正只要是我觉得值得记录的东西，不管文字多或少我都会记录下来，因为它们都是我成长的一部分，以后回顾起来，肯定别有一番感觉。 再来介绍一下俺自己。俺目前正在学习前端中，属于很菜鸡的那种…目前正在努力中，今年一定要找到工作！自律性比较差，学习热情时高时低，时不时会反思一下自己。个人是比较肥宅的，爱好网上冲浪，屁话超多。但是对事物充满兴趣，也算是长跑型选手吧，有时也会去填填以前挖的坑，跑得不快但是会努力争取跑完(说到这里，我想到我以前小学的时候田径队暑假训练连测三次400米，每次我的速度几乎都只相差几秒这样，体育老师说我耐力很好但是跑得不快有啥用== 说如果我参加爬长城的话，就算我登顶了但也是最后一个登顶的…嗨呀，俺也不知道俺突然说这一段干啥hhh) 最后立个Flag吧~ 其实很早以前就有搭博客的意识了，但是总是花了时间捣鼓了好几天就没下文了，下一次开始时又重头再来…希望这次不要删掉了，有困难就解决，解决不了就过段时间再解决，千万不要再删除重新再来了== 加油 No one can help me, except me. 2020年4月26日","link":"/about/index.html"}],"posts":[{"title":"JavaScript中的this","text":"this是什么this是一个很特别的关键字，它是在函数被调用时发生的绑定，并不是在编写时进行绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。 this绑定规则在理解this的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的位置。最重要的就是分析调用栈(为了到达执行位置所调用的所有函数)。调用位置就在当前正在执行的函数的前一个调用中。 12345678910111213141516function baz() { console.log(\"baz\"); bar();}function bar() { console.log(\"bar\"); foo();}function foo() { debugger; console.log(\"foo\");}baz(); 如果想要分析this的绑定，使用开发工具得到调用栈，栈中的第二个元素即为真正的调用位置。上图foo函数的调用位置为bar函数中。 默认绑定最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。 非严格模式下，默认绑定规则将this绑定到全局对象上。严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。 123456789//非严格模式下function foo() { var a = 1; console.log(this.a);}var a = 2;foo(); //2 全局对象上的变量a 12345678//严格模式下\"use strict\";function foo() { console.log(\"this: \", this);}foo(); //\"this: undefined\" 隐式绑定当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。 1234567891011function foo() { var a = 0; console.log(this.a);}var obj = { a: 1, foo: foo};obj.foo(); //1 调用foo()时this被绑定到obj上 被隐式绑定的函数有时会丢失绑定对象，应用默认绑定，从而将this绑定到全局对象或者undefined上(取决于是否是严格模式) 12345678910111213141516function foo() { var a = 0; console.log(this.a);}var obj = { a: 1, foo: foo};var bar = obj.foo; //函数别名var a = 2;bar(); //2//虽然bar是obj.foo的一个引用，但是实际上它引用的是foo函数本身//此时的bar()其实是一个不带任何修饰符的函数调用，因此应用默认绑定 回调函数丢失this绑定也是很常见的，无论哪种情况，this的改变都是意想不到的。 123456789101112131415161718192021222324function foo() { var a = 0; console.log(this.a);}var obj = { a: 1, foo: foo};var a = \"global a\";setTimeout(obj.foo, 1000);//1秒后执行函数obj.foo// \"global a\"/*JavaScript环境中内置的setTimeout()函数实现和下面伪代码类似：function setTimeout(fn, delay) { //等待delay秒 fn();}*///参数传递其实是一种隐式赋值，这里相当于fn = obj.foo,所以结果同上例 隐式绑定可理解为我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而将this间接(隐式)绑定到这个对象上。 显式绑定如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，则可以使用显示绑定。具体点就是使用函数的call(…)和apply(…)方法。 Function.prototype.call([thisArg[, arg1, arg2,…argN]]);Function.prototype.apply(thisArg, [ argsArray]);这两个方法的thisArg参数就是给this准备的，在调用函数时将this直接绑定到thisArg上。因为我们可以直接指定this的绑定对象，因此我们称之为显式绑定。 123456789101112var person1 = { fullName: function() { return this.firstName + \" \" + this.lastName; }}var person2 = { firstName: \"Lucy\", lastName: \"Wang\"};person1.fullName.call(person2); // \"Lucy Wang\" 但是显式绑定仍然无法解决我们之前提出的丢失绑定的问题。显示绑定的一个变种-硬绑定则可以解决 12345678910111213141516171819202122232425function foo() { var a = 0; console.log(this.a);}var obj = { a: 1, foo: foo};var a = \"global a\";var bar = function() { foo.call(obj);};bar(); //1bar.call(window); //1setTimeout(bar, 1000); //1/*创建了函数bar(),在它内部手动调用foo.call(obj),强制的把foo的this绑定到了obj无论之后如何调用函数bar，它总会手动在obj上调用foo这种绑定是一种显式的强制绑定，称之为硬绑定*/ 由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法Function.prototype.bind bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被指定为bind()的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 new绑定在传统的面向类的语言中，”构造函数”是类中的一些特殊方法，使用new初始化类时会调用类中的构造函数。JS中也有一个new操作符，但是JS中new的机制实际上和面向类的语言完全不同。 在JavaScript中，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。 包括内置对象函数在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。实际上并不存在所谓的”构造函数”，只有对函数的”构造调用” 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建(或者说构造)一个全新的对象 这个新对象会被执行[[Prototype]]连接 这个新对象会被绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 1234567function Person(name) { this.name = name;}var person = new Person(\"Lucy\");console.log(person.name); //\"Lucy\" this绑定优先级我们已经了解了函数调用中this绑定的四条规则，只需要找到函数的调用位置并判断应有哪条规则就行。但是，如果某个调用位置可以应用多条规则的话，则必须给这些规则设定优先级。 默认绑定的优先级是四条规则中最低的。 隐式绑定vs显式绑定123456789101112131415161718192021function foo() { console.log(this.a);}var obj1 = { a: 1, foo: foo};var obj2 = { a: 2, foo: foo};//隐式绑定obj1.foo(); //1obj2.foo(); //2//运用了隐式绑定and显式绑定obj1.foo.call(obj2); //2obj2.foo.call(obj1); //1 显式绑定优先级高于隐式绑定 new绑定vs隐式绑定1234567891011121314function foo(something) { this.a = something;}var obj1 = { foo: foo};obj1.foo(1);//隐式绑定console.log(obj1.a); //1var bar = new obj1.foo(2); //运用了new绑定and隐式绑定console.log(obj1.a); //1console.log(bar.a); //2 new绑定比隐式绑定优先级高 new绑定vs硬绑定12345678910111213function foo(something) { this.a = something;}var obj1 = {};var bar = foo.bind(obj1); //硬绑定 bar被硬绑定到obj1上bar(2);console.log(obj1.a); //2var baz = new bar(3); //应用了硬绑定的基础上再应用new绑定console.log(obj1.a); //2console.log(baz.a); //3 new绑定修改了硬绑定到obj1上的bar函数调用中的this new绑定比硬绑定优先级高 优先级小结可以根据优先级来判断函数在某个位置应用的是哪条规则。可以按照下面的顺序进行判断： 函数是否在new中调用(new绑定)？如果是的话this绑定的就是新创建的对象。 函数是否通过call、apply(显式绑定)或硬绑定调用？如果是的话，this绑定的是指定的对象。 函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this绑定的是那个上下文对象。 如果都不是的话，使用默认绑定。在严格模式下，绑定到undefined,否则绑定到全局对象。 参考内容 《你不知道的JavaScript上卷》第二部分 MDN Function.prototype.call() MDN Function.prototype.apply()","link":"/2020/05/05/JavaScript%E4%B8%AD%E7%9A%84this/"},{"title":"JavaScript中的原型","text":"简述我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。 在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性是一个指向prototype属性所在函数的指针。 123function foo() {};foo.prototype.constructor === foo; //true 实例对象与原型对象关系简述123456function Person() { };var lucy = new Person();console.log(lucy.constructor === Person); //true//在实例对象上找不到的属性和方法会在其构造函数的原型对象上进一步查找 实例对象如何访问原型Firefox、Safari和Chrome在每个对象上都支持一个属性__proto__；这个连接存在于实例和构造函数的原型对象之间 其它方法访问对象的[[Prototype]]属性 isPrototypeOf()：间接确定对象的原型 1console.log(Person.prototype.isPrototypeOf(lucy)); //true Object.getPrototypeOf()：直接返回对象的原型 1console.log(Object.getPrototypeOf(lucy) === Person.prototype); //true 属性判断当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，使用hasOwnProperty()方法可以检测一个属性是存在实例对象中，还是存在于原型中。 123456789function Person() { name: \"Bob\"};var person = new Person();console.log(person.hasOwnProperty(\"name\")); //falseperson.name = \"Lucy\";console.log(person.hasOwnProperty(\"name\")); //true 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。 123456789function Person() {};var person = new Person();Person.prototype.sayHi = function() { alert(\"Hi\");};person.sayHi(); // \"Hi\" 重写原型尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，情况就有所不同。 调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，但是把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。 12345678910function Person() {};var person = new Person();Person.prototype = { constructor: Person, name: \"Lucy\"};console.log(person.name); // undefined 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系。对象实例引用的仍然是最初的原型。 原型模式缺点原型中所有属性是被很多实例所共享的，这种共享对于函数来说非常合适，对于包含基本值的属性值也还说得过去(因为在实例对象上添加一个同名属性会屏蔽掉原型中的对应属性)，但是对于包含引用类型值的属性来说问题比较突出，因为任何一个实例对象修改了原型中的引用类型的属性值后，所有其他实例对象中对应的引用类型值均发生改变。 1234567891011121314function Person() {};Person.prototype = { constructor: Person, friends: [\"Handy\", \"Mona\"]};var person1 = new Person();var person2 = new Person();person1.friends.push(\"May\");console.log(person1.friends); //[\"Handy\", \"Mona\",\"May\"]console.log(person2.friends); //[\"Handy\", \"Mona\",\"May\"]console.log(person1.friends === person2.friends); //true 所以自定义类型的最常见方式就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。 原型链简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针(constructor),而实例都包含一个指向原型对象的内部指针[[Prototype]]。 那么，假如，我们让原型对象等于另一个类型的实例，则此时的原型对象将包含指向另一个原型的指针[[Prototype]],它也有自己的原型，因此会形成一个原型链(prototype chain)：对象到原型，再到原型的原型…如果一层层上溯，所有对象的原型最终都可以上溯到Object.prototype,也就是说，所有对象都继承了Object.prototype的属性。 12345678910111213141516171819202122232425262728293031function Animal() { this.eats = true;};Animal.prototype.walk = function() { return \"Animal's walk\";};function Pig() { this.earNum = 2;};Pig.prototype = new Animal(); //继承了AnimalPig.prototype.sleep = function() { return \"Pig's sleep\";};function FlowerPig() { this.skin = \"flower\";}FlowerPig.prototype = new Pig(); //继承了Pigvar pig1 = new FlowerPig();console.log(pig1.skin); //flowerconsole.log(pig1.sleep()); // \"Pig's sleep\"console.log(pig1.earNum); //2console.log(pig1.walk());// \"Animal's walk\"console.log(pig1.eats); //true 当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上，搜索过程总是要一环一环的前行到原型链末端才会停下来。 在通过原型来实现继承时，原型实际上是另一个类型的实例，所以原先的实例属性也就变成了现在的原型属性，所以还是需要注意包含引用类型值的原型。 参考内容 《JavaScript高级程序设计第三版》 第六章 阮一峰JavaScript教程-对象的继承","link":"/2020/05/03/JavaScript%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B/"},{"title":"JavaScript中的作用域","text":"作用域是什么要了解一丢丢编译原理知识尽管通常将JavaScript归类为”动态”或”解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言又不同，它不是提前编译的，大部分情况下JS的编译都发生在代码执行前的几微秒(甚至更短)的时间内。 在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为”编译”。 分词/词法分析 这个过程会将由字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元(token)。e.g var a = 2; 会被分解为：var、a、=、;。4个词法单元 解析/语法分析 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，这个树被称为”抽象语法树”(AST)。 代码生成 将AST转换为可执行的过程被称为代码生成。简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等),并将一个值存储在a中。 理解作用域模拟对话学习作用域的方式是将这个过程模拟成几个人物之间的对话登场人物： 引擎： 从头到尾负责整个JavaScript程序的编译及执行过程 编译器： 负责语法分析及代码生成等脏活累活 作用域： 负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 对话模拟： 场景：var a = 2; 旁白：编译器首先将这段程序分解成词法单元，然后将词法单元解析为一个树结构，接下来，编译器开始进行代码生成… 编译器：Hi，作用域，a在不在你的作用域集合里面呀？ 当前作用域(a在的话)：在呢 编译器：okk,没事了 当前作用域(a不在)：不在的 编译器：好滴，那麻烦你帮我声明一个叫a的变量吧，蟹蟹。 旁白：接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作 引擎：哈喽，作用域~你集合里面有没有一个叫a的变量呀？ 当前作用域(a在)：有的大哥，刚刚编译器叫我声明了变量a 引擎：好的，我把2赋值给它 当前作用域(a不在)：不好意思大哥，当前集合里面没有a 引擎：没事儿，我再找找(继续询问上一级作用域) 所以变量的赋值操作会执行两个动作： 首先编译器会在当前作用域中声明一个变量(如果之前没有声明过) 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值 引擎查找变量方式编译器在编译过程中生成了代码，引擎执行它时，会通过查找变量来判断该变量是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。 如果将变量比作一个盒子的话，盒子里装的东西就是变量的值,引擎会为变量进行两种类型的查找 LHS查询：找到盒子，向里面放值 RHS查询：取到盒子里面的值 1234567891011121314//小测验演示 function foo(a) { var b = a; return a + b; } var c = foo(2);/* 1. foo(...) RHS 2. a = 2; LHS 3. b = a LHS(b=...)、RHS(a) 4. a + b RHS(a)、RHS(b) 5. c = ... LHS */ 作用域嵌套当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(全局作用域)为止。 123456789 function foo(a) { console.log(a + b); } var b = 2; foo(2); //4//对b进行RHS查询无法在foo函数内部完成，但可以在上一级作用域(这里即为全局作用域)中完成 异常为什么区分LHS和RHS是一件重要的事情呢？因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为是不一样的。 如果RHS查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出ReferenceError异常。想较之下，当引擎执行LHS查询时，如果在顶层(全局作用域)中也无法找到目标变量时，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。(程序需运行在非”严格模式”下) ES5中引入了严格模式，在严格模式下LHS查询失败的话，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。 如果RHS查询成功了，但是你尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎会抛出另外一种类型的异常，叫做TypeError。 ReferenceError同作用域判别失败相关。TypeError则表示作用域判别成功了，但是对结果的操作是非法或不合理的。 词法作用域作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另一种叫做动态作用域，仍有一些编程语言(如Bash脚本、Perl中的一些模式等)在使用。 词法阶段大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下如此)。 123456789101112131415161718function foo(a) { var b = a * 2; function bar(c) { console.log(a, b, c); } bar(b*3);}foo(2); // 2 4 12/*作用域气泡是由其对应的作用域代码写在哪里决定，它们是逐级包含的。这里共有三个逐级嵌套的作用域 作用域1：包含整个全局作用域，其中只有一个标识符：foo 作用域2：包含着foo所创建的作用域，其中有三个标识符：a、b、bar作用域3：包含着bar所创建的作用域，其中只有一个标识符：c*/ 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。 作用域查找会在找到第一个匹配的标识符时停止。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法词法作用域完全由写代码期间函数所声明的位置来定义，但JavaScript也提供了两种机制用来欺骗词法作用域。 欺骗词法作用域会导致性能下降，事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。但是有关欺骗词法的机制，还是有必要了解一下的。 evalJavaScript中的eval(…)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，借此来修改已经存在的词法作用域(在运行时) 12345678function foo(str, a) { eval(str); //欺骗 给人感觉var b = 3就是一直在这的 console.log(a, b);}var b = 2;foo(\"var b = 3\", 1); //1 3 withwith本质是通过将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域(运行时) 1234567891011121314151617181920212223242526272829function foo(obj) { with(obj) { a = 2; }}var o1 = { a: 3};var o2 = { b: 3};foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //undefinedconsole.log(a); //2 a被泄露到全局作用域上了/*代码理解传递o1给with时，with所声明的作用域是o1,而这个作用域中已经有一个o1.a的标识符了，LHS查询成功，所以执行a=2只是将变量a这个盒子里面的值进行改变。传递o2给with时，with所声明的作用域是o2，进行LHS查找失败，此为非严格模式下，所以LHS失败后，全局作用域中就会创建一个名为a的变量盒子。*/ 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块作用域中，而是被添加到with所处的函数作用域中 1234567891011121314151617181920212223242526272829303132333435function foo(obj) { with(obj) { var c = 1; var a = 4; a = 2; } console.log(c); console.log(a);}var o1 = { a: 3};foo(o1);console.log(o1.a);/*运行结果：1 //c的值， var c = 1;相当于添加在with所处的函数作用域(此处即为foo作用域)中undefined //传递o1给with时，进行LHS查询，已有标识符o1.a存在，忽略var a = 4;声明，所以foo作用域中无变量a2 // LHS查询成功，将o1.a中的值变为了2*/var o2 = { b: 3};foo(o2);console.log(o2.a);/*运行结果：1 //c的值2 //传递o2给with时，进行LHS查询，无变量a,a被添加到foo作用域中undefined //o2并没有a属性*/ 性能JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但eval(…)和with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。因此，所有的优化可能都是无意义的，代码因此性能降低，运行变慢。所以不要使用欺骗词法。 函数作用域和块作用域作用域包含了一系列”气泡”，每一个都可以作为容器，其中包含了标识符(变量、函数)的定义。这些气泡互相嵌套并且整齐的排列成蜂窝型，排列的结构是在写代码时定义的。 函数中的作用域函数中的作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用。 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义”隐藏”起来，外部作用域就无法访问包装函数内部的任何内容，达到内容私有化效果，最小限度的暴露必要内容。 1234567function foo() { var a = 1; console.log(a);}foo(); //1 在函数内部可以访问到变量a console.log(a); // ReferenceError 外部访问不到变量a 虽然这种技术解决了一些问题(如变量私有化)，但是会导致一些额外的问题： 必须声明一个具名函数foo(),foo这个名称本身就”污染”了所在的作用域 必须显式的通过函数名调用这个函数才能运行其中的代码 解决方法：使用函数表达式 12345678(function foo() { var a = 1; console.log(a);})(); //1 /*(function foo() {...})作为函数表达式意味着foo只能在...所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要的污染外部作用域*/ 块作用域ES6之前在ES6之前，JavaScript表面上是没有块级作用域这个概念的 12345678910for(var i = 0; i &lt; 2; i++) { console.log(i);}//依次输出0 1console.log(i);//2/*通常我们定义的变量i只是想要在for循环的上下文中使用但是，使用var声明变量时，它写在哪里都是一样的，最终都会属于外部作用域(这里为全局作用域)*/ 但也有使用块级作用域的例子 with：用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效 try/catch：catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效 ES6之后ES6之后，引入了新的关键字：let和const,变量声明方式变为了3种 var声明变量ES6之前，变量一直使用var关键字进行变量声明 用var声明的变量，不是函数作用域就是全局作用域，没有块级作用域 var声明存在变量提升(使用var声明的变量无论在何处声明，都会被”移动”到作用域的最顶端) 12console.log(a); //undefined 按道理应该是RHS查询失败，产生ReferenceError， 但是存在变量提升，var a;被\"移动\"到了这行代码前var a = 1; let声明变量let关键字可以将变量绑定到所在的任意作用域中(通常是{…}内部) 1234567for(let i = 0; i &lt; 2; i++) { console.log(i);}//依次输出0 1console.log(i);//ReferenceError//for循环外，变量i不可访问 使用let进行的声明不会在块作用域中进行提升 1234if(true) { console.log(a); //ReferenceError let a = 1;} const声明变量const同样可以用来创建块作用域，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误 123456if(true) { console.log(PI); //ReferenceError 不可变量提升 const PI = 3.14; PI = 4;//TypeError 不可修改}console.log(PI); //ReferenceError 不可外部访问 参考内容 《你不知道的JavaScript上卷》 第一部分","link":"/2020/04/29/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"JavaScript中的属性描述对象","text":"简述JavaScript提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为”属性描述对象”。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。 属性描述对象共提供6个元属性 value：属性的属性值，默认为undefined writable：布尔值，表示属性值value是否可写，默认为true enumerable：布尔值，表示该属性是否可遍历，默认为true configurable：布尔值，表示可配置性，控制属性描述对象的可写性，默认为true get：是一个函数，表示该属性的取值函数(getter)，默认为undefined set：是一个函数，表示该属性的存值函数(setter)，默认为undefined ECMA-262定义这些元属性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们，为了表示它们是内部值，将它们放在两对方括号中。(e.g [[configurable]]) ECMAScript中有两种属性： 数据属性 访问器属性 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值，数据属性有4个描述其行为的元属性 [[configurable]] [[enumerable]] [[writable]] [[value]] 123456789101112131415161718192021222324let person = { age: 1};//获取person对象的age属性的属性描述对象console.log(Object.getOwnPropertyDescriptor(person, \"age\")); /*{ configurable: true, enumerable: true, value: 1, writable: true}*/Object.defineProperty(person, \"age\", { value: 2, writable: false, //不可写 configurable: true, enumerable: true});person.age = 3; //非严格模式下忽略写入，严格模式下出现TypeErrorconsole.log(person.age); //2 只要属性是可配置的，即configurable为true的话，即可使用defineProperty()方法来修改属性描述符 12345678910111213141516171819202122232425let obj = { a: 0};Object.defineProperty(obj, \"a\", { configurable: false //不可配置});obj.a = 1;console.log(obj.a); //1 不可配置指的是不可配置属性描述符Object.defineProperty(obj, \"a\", { configurable: true}); // TypeError //不管是否处于严格模式，把configurable修改为false是一个单向操作，尝试修改一个不可配置的属性描述符都会出错Object.defineProperty(obj, \"a\", { writable: false}); //但是，即便configurable: false,还是可以将writable的状态由true改为false 但是无法由false改为trueObject.defineProperty(obj, \"a\", { writable: true //TypeError}); delete obj.a; //false 除了无法修改，configurable: false还会禁止删除这个属性 enumerable这个描述符控制的是属性是否会出现在对象的属性枚举中 12345678910111213141516171819let person = { age: 23, name: \"Lucy\", female: true};for (let attr in person) { console.log(attr);};//依次打印 age name femaleObject.defineProperty(person, \"name\", { enumerable: false});for (let attr in person) { console.log(attr);};//依次打印 age female 访问器属性访问器属性不包含数据值，它们包含一对getter和setter函数(非必需) 在读取访问器属性时，会调用getter函数；在写入访问器属性时，会调用setter函数并传入新值，这个函数决定如何处理数据访问器属性有4个描述其行为的元属性 [[configurable]] [[enumerable]] [[get]] [[set]] 访问器属性不能直接定义，必须使用Object.defineProperty()定义 123456789101112131415161718let person = { birth: 1996, _year: 2019, //下划线是一种常用的记号，用于表示只能通过对象方法访问的属性 age: 23};Object.defineProperty(person, \"year\", { get: function() { return this._year; }, set: function(newYear) {//访问器属性的常见方式即设置一个属性的值会导致其它属性发生变化 this._year = newYear; this.age = newYear - this.birth; }});person.year = 2024;console.log(person.age); //28 不一定非要同时指定getter和setter，只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似的，只指定setter函数的属性不能读，否则在非严格模式下返回undefined，而在严格模式下会抛出错误。 1234567891011121314\"use strict\";let person = { birth: 1996, _year: 2019, //下划线是一种常用的记号，用于表示只能通过对象方法访问的属性 age: 23};Object.defineProperty(person, \"year\", { get: function() { return this._year; }});person.year = 2024; //TypeError 参考内容 阮一峰JavaScript教程-属性描述对象 《你不知道的JavaScript上卷》第二部分 第三章 《JavaScript高级程序设计第三版》 第6章","link":"/2020/05/01/JavaScript%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1/"},{"title":"JavaScript中的数据类型","text":"数据类型分类JavaScript中共有8种数据类型 number bigint string boolean null undefined symbol object 数据类型简述基本数据类型number数值类型，可以表示整数或者小数。除了常规的数字外，还包括”特殊数值”：Infinity、-Infinity、NaN 123456var num1 = 1;var num2 = 1.3;alert(1/0); //Infinityalert(Infinity); //Infinityalert(\"hhh\"/1); //NaN NaN表示一个计算错误。作用是为了使得数学运算是安全的，从而脚本不会因为错误的运算而停止typeof num1; //\"number\" string字符串类型，必须放在引号中 双引号：”Flecy” 单引号： ‘Flecy’ 反引号： `Flecy`单引号双引号无区别，反引号是功能扩展引号，允许将变量和表达式包装在${…}中，然后嵌入到字符串中。 1234var name = \"Flecy\";alert(`Hi, ${name}`); // \"Hi, Flecy\"alert(`${1+2}`); //3 boolean只包含两个值：true和false 12var result = true;typeof result; //\"boolean\" null只含null一个值 12var result = null;typeof result; //\"object\" null不是一个object,null有自己的类型，它就是一个特殊值，typeof null的结果为”object”是JavaScript语言的一个错误，为了兼容性保留下来了。 undefined只含undefined一个值,undefined的含义是未被赋值。如果一个变量已经被声明，但没有赋值，那么它的值就是undefined。 12var result;typeof result; //\"undefined\" 复杂数据类型object各种值组成的集合，用于存储数据集合和更复杂的实体 12345678var blog = { name: \"弗蕾西\", domain: \"manylu.com\", owner: \"Flecy\", age: 1};typeof blog; // \"object\" 新增加的数据类型不太想把这两个数据类型放在基本数据类型中，也算是为了更好的区分JS的变化吧，所以单独把它们放在第三类中。 symbol用于创建对象的唯一标识符因为ES5的对象属性名都是字符串，为了保证每个属性的名字都是独一无二的，从根本上防止属性名的冲突，引入了symbol类型symbol值通过Symbol函数生成 12var s = symbol();typeof s; // \"symbol\" Symbol函数前不能使用new命令，否则会报错，因为生成的symbol是一个原始类型的值，不是对象。 bigint用于表示任意长度的整数，在JavaScript中，”number”类型无法代表大于2^53(或小于-2^53)的整数。通过将n添加到整数字段末尾来创建bigint类型。 12var bigInt = 123456789n;typeof bigInt; // \"bigint\" 存在兼容性问题：Firefox和Chrome已经支持bigint了，但是Safari/IE/Edge还没有 typeof运算符typeof运算符可以返回一个值的数据类型除了上面代码中返回的类型外，函数也会特别返回 123typeof alert; // \"function\"typeof []; // \"object\"typeof {}; // \"object\" JavaScript中没有一个特别的”function”类型，函数隶属于object类型，但是typeof会对函数区别对待typeof区分不了对象的细节，是数组或者是其他对象，只能确定对象的大类 typeof可以用来检查一个没有声明的变量而不会报错 123t; // Uncaught ReferenceError: t is not definedtypeof t; // \"undefined\" 参考链接 阮一峰JavaScript教程-数据类型 现代JavaScript教程-数据类型 Symbol-ES6入门","link":"/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"脑壳有点乱","text":"今天脑壳有.乱 时间过得好快呀，我是2019年6月8号回的家，马上快要在家待满一年了，还差39天。 当时一战失败，在寝室的床上翻来覆去就是睡不着觉，技术也不行，找工作没有勇气也没有信心，现在想想，当初甚至简历都没有投几份…下定决心二战之后，心里好像就放松了下来，继续慢悠悠做着毕业设计，和小伙伴玩游戏、吃东西、聊天…然后匆匆结束大学生活，真是懦弱啊当时，虽然现在也是… 回到家之后悠闲的浪费了很多的时间，最后二战也失败了，数学真的杀我== 二战压力真的不知道该怎么形容，虽然也有偷懒，但也努力过，脑壳里却总是想东想西的专注不下来，终究是高估了自己…错付了期待。数学考完其实已经知道自己失败了，心情就是很down，那种在考场里面看着试卷大脑空白，后背发凉的感觉我可能永远也忘不了吧…当时也有决定考完马上认真学习然后出去找工作的，结果随着时间意志又被慢慢削弱…再后来赶上家人住院，除夕夜都是在医院病房的凳子上度过的…再然后疫情爆发，大家都待在家里，没有了紧张感，学习也是有一搭没一搭的缓慢进行中，反应过来已经是4月底了… 我不喜欢反复，但我却是一个总在反复的人，反复的看书，因为不连续的学习，之前看的又忘了，又反复的重新看书…一本书总是只有前几章有使用痕迹…反复的给自己定目标、定计划，然后不去执行，又反复的重新开始…啊！我真是看透了自己== 现在的实习生已经在21届里面找了，不知不觉中就成了老腊肉了，19毕业，至今没有工作过的老腊肉… 这次，我想再给自己一个期限。 看到知乎上有说”找实习最重要的事情，就是迈出面试的一步”。 所以我想以这39天为一个期限，去准备简历、尽可能的补充知识，不管39天以后准备的如何，都去迈出投简历的一步。 加油","link":"/2020/04/30/%E8%84%91%E5%A3%B3%E6%9C%89%E7%82%B9%E4%B9%B1/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"},{"name":"心情","slug":"心情","link":"/tags/%E5%BF%83%E6%83%85/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}