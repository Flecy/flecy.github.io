{"pages":[{"title":"friends","text":"","link":"/friends/index.html"},{"title":"关于俺的一点点碎碎念","text":"哈喽，大家好，欢迎来到弗蕾西！ 先说一下搭建这个博客的初衷：主要是想要在互联网上留下一些属于自己的印记，所以博客会以学习记录为主。最主要的还是记录学习过程中遇到的一些困难以及怎样解决它们的亦或是总结知识点、记录学习收获这类内容。反正只要是我觉得值得记录的东西，不管文字多或少我都会记录下来，因为它们都是我成长的一部分，以后回顾起来，肯定别有一番感觉。 再来介绍一下俺自己。俺目前正在学习前端中，属于很菜鸡的那种…目前正在努力中，今年一定要找到工作！自律性比较差，学习热情时高时低，时不时会反思一下自己。个人是比较肥宅的，爱好网上冲浪，屁话超多。但是对事物充满兴趣，也算是长跑型选手吧，有时也会去填填以前挖的坑，跑得不快但是会努力争取跑完(说到这里，我想到我以前小学的时候田径队暑假训练连测三次400米，每次我的速度几乎都只相差几秒这样，体育老师说我耐力很好但是跑得不快有啥用== 说如果我参加爬长城的话，就算我登顶了但也是最后一个登顶的…嗨呀，俺也不知道俺突然说这一段干啥hhh) 最后立个Flag吧~ 其实很早以前就有搭博客的意识了，但是总是花了时间捣鼓了好几天就没下文了，下一次开始时又重头再来…希望这次不要删掉了，有困难就解决，解决不了就过段时间再解决，千万不要再删除重新再来了== 加油 No one can help me, except me. 2020年4月26日","link":"/about/index.html"}],"posts":[{"title":"JavaScript中的作用域","text":"作用域是什么要了解一丢丢编译原理知识尽管通常将JavaScript归类为”动态”或”解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言又不同，它不是提前编译的，大部分情况下JS的编译都发生在代码执行前的几微秒(甚至更短)的时间内。 在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为”编译”。 分词/词法分析 这个过程会将由字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元(token)。e.g var a = 2; 会被分解为：var、a、=、;。4个词法单元 解析/语法分析 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，这个树被称为”抽象语法树”(AST)。 代码生成 将AST转换为可执行的过程被称为代码生成。简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等),并将一个值存储在a中。 理解作用域模拟对话学习作用域的方式是将这个过程模拟成几个人物之间的对话登场人物： 引擎： 从头到尾负责整个JavaScript程序的编译及执行过程 编译器： 负责语法分析及代码生成等脏活累活 作用域： 负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 对话模拟： 场景：var a = 2; 旁白：编译器首先将这段程序分解成词法单元，然后将词法单元解析为一个树结构，接下来，编译器开始进行代码生成… 编译器：Hi，作用域，a在不在你的作用域集合里面呀？ 当前作用域(a在的话)：在呢 编译器：okk,没事了 当前作用域(a不在)：不在的 编译器：好滴，那麻烦你帮我声明一个叫a的变量吧，蟹蟹。 旁白：接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作 引擎：哈喽，作用域~你集合里面有没有一个叫a的变量呀？ 当前作用域(a在)：有的大哥，刚刚编译器叫我声明了变量a 引擎：好的，我把2赋值给它 当前作用域(a不在)：不好意思大哥，当前集合里面没有a 引擎：没事儿，我再找找(继续询问上一级作用域) 所以变量的赋值操作会执行两个动作： 首先编译器会在当前作用域中声明一个变量(如果之前没有声明过) 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值 引擎查找变量方式编译器在编译过程中生成了代码，引擎执行它时，会通过查找变量来判断该变量是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。 如果将变量比作一个盒子的话，盒子里装的东西就是变量的值,引擎会为变量进行两种类型的查找 LHS查询：找到盒子，向里面放值 RHS查询：取到盒子里面的值 1234567891011121314//小测验演示 function foo(a) { var b = a; return a + b; } var c = foo(2);/* 1. foo(...) RHS 2. a = 2; LHS 3. b = a LHS(b=...)、RHS(a) 4. a + b RHS(a)、RHS(b) 5. c = ... LHS */ 作用域嵌套当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(全局作用域)为止。 123456789 function foo(a) { console.log(a + b); } var b = 2; foo(2); //4//对b进行RHS查询无法在foo函数内部完成，但可以在上一级作用域(这里即为全局作用域)中完成 异常为什么区分LHS和RHS是一件重要的事情呢？因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为是不一样的。 如果RHS查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出ReferenceError异常。想较之下，当引擎执行LHS查询时，如果在顶层(全局作用域)中也无法找到目标变量时，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。(程序需运行在非”严格模式”下) ES5中引入了严格模式，在严格模式下LHS查询失败的话，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。 如果RHS查询成功了，但是你尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎会抛出另外一种类型的异常，叫做TypeError。 ReferenceError同作用域判别失败相关。TypeError则表示作用域判别成功了，但是对结果的操作是非法或不合理的。 词法作用域作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另一种叫做动态作用域，仍有一些编程语言(如Bash脚本、Perl中的一些模式等)在使用。 词法阶段大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下如此)。 123456789101112131415161718function foo(a) { var b = a * 2; function bar(c) { console.log(a, b, c); } bar(b*3);}foo(2); // 2 4 12/*作用域气泡是由其对应的作用域代码写在哪里决定，它们是逐级包含的。这里共有三个逐级嵌套的作用域 作用域1：包含整个全局作用域，其中只有一个标识符：foo 作用域2：包含着foo所创建的作用域，其中有三个标识符：a、b、bar作用域3：包含着bar所创建的作用域，其中只有一个标识符：c*/ 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。 作用域查找会在找到第一个匹配的标识符时停止。 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 欺骗词法词法作用域完全由写代码期间函数所声明的位置来定义，但JavaScript也提供了两种机制用来欺骗词法作用域。 欺骗词法作用域会导致性能下降，事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。但是有关欺骗词法的机制，还是有必要了解一下的。 evalJavaScript中的eval(…)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，借此来修改已经存在的词法作用域(在运行时) 12345678function foo(str, a) { eval(str); //欺骗 给人感觉var b = 3就是一直在这的 console.log(a, b);}var b = 2;foo(\"var b = 3\", 1); //1 3 withwith本质是通过将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域(运行时) 1234567891011121314151617181920212223242526272829function foo(obj) { with(obj) { a = 2; }}var o1 = { a: 3};var o2 = { b: 3};foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //undefinedconsole.log(a); //2 a被泄露到全局作用域上了/*代码理解传递o1给with时，with所声明的作用域是o1,而这个作用域中已经有一个o1.a的标识符了，LHS查询成功，所以执行a=2只是将变量a这个盒子里面的值进行改变。传递o2给with时，with所声明的作用域是o2，进行LHS查找失败，此为非严格模式下，所以LHS失败后，全局作用域中就会创建一个名为a的变量盒子。*/ 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块作用域中，而是被添加到with所处的函数作用域中 1234567891011121314151617181920212223242526272829303132333435function foo(obj) { with(obj) { var c = 1; var a = 4; a = 2; } console.log(c); console.log(a);}var o1 = { a: 3};foo(o1);console.log(o1.a);/*运行结果：1 //c的值， var c = 1;相当于添加在with所处的函数作用域(此处即为foo作用域)中undefined //传递o1给with时，进行LHS查询，已有标识符o1.a存在，忽略var a = 4;声明，所以foo作用域中无变量a2 // LHS查询成功，将o1.a中的值变为了2*/var o2 = { b: 3};foo(o2);console.log(o2.a);/*运行结果：1 //c的值2 //传递o2给with时，进行LHS查询，无变量a,a被添加到foo作用域中undefined //o2并没有a属性*/ 性能JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 但eval(…)和with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。因此，所有的优化可能都是无意义的，代码因此性能降低，运行变慢。所以不要使用欺骗词法。 函数作用域和块作用域作用域包含了一系列”气泡”，每一个都可以作为容器，其中包含了标识符(变量、函数)的定义。这些气泡互相嵌套并且整齐的排列成蜂窝型，排列的结构是在写代码时定义的。 函数中的作用域函数中的作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用。 在任意代码片段外部添加包装函数，可以将内部的变量和函数定义”隐藏”起来，外部作用域就无法访问包装函数内部的任何内容，达到内容私有化效果，最小限度的暴露必要内容。 1234567function foo() { var a = 1; console.log(a);}foo(); //1 在函数内部可以访问到变量a console.log(a); // ReferenceError 外部访问不到变量a 虽然这种技术解决了一些问题(如变量私有化)，但是会导致一些额外的问题： 必须声明一个具名函数foo(),foo这个名称本身就”污染”了所在的作用域 必须显式的通过函数名调用这个函数才能运行其中的代码 解决方法：使用函数表达式 12345678(function foo() { var a = 1; console.log(a);})(); //1 /*(function foo() {...})作为函数表达式意味着foo只能在...所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要的污染外部作用域*/ 块作用域ES6之前在ES6之前，JavaScript表面上是没有块级作用域这个概念的 12345678910for(var i = 0; i &lt; 2; i++) { console.log(i);}//依次输出0 1console.log(i);//2/*通常我们定义的变量i只是想要在for循环的上下文中使用但是，使用var声明变量时，它写在哪里都是一样的，最终都会属于外部作用域(这里为全局作用域)*/ 但也有使用块级作用域的例子 with：用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效 try/catch：catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效 ES6之后ES6之后，引入了新的关键字：let和const,变量声明方式变为了3种 var声明变量ES6之前，变量一直使用var关键字进行变量声明 用var声明的变量，不是函数作用域就是全局作用域，没有块级作用域 var声明存在变量提升(使用var声明的变量无论在何处声明，都会被”移动”到作用域的最顶端) 12console.log(a); //undefined 按道理应该是RHS查询失败，产生ReferenceError， 但是存在变量提升，var a;被\"移动\"到了这行代码前var a = 1; let声明变量let关键字可以将变量绑定到所在的任意作用域中(通常是{…}内部) 1234567for(let i = 0; i &lt; 2; i++) { console.log(i);}//依次输出0 1console.log(i);//ReferenceError//for循环外，变量i不可访问 使用let进行的声明不会在块作用域中进行提升 1234if(true) { console.log(a); //ReferenceError let a = 1;} const声明变量const同样可以用来创建块作用域，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误 123456if(true) { console.log(PI); //ReferenceError 不可变量提升 const PI = 3.14; PI = 4;//TypeError 不可修改}console.log(PI); //ReferenceError 不可外部访问 参考内容 &lt;&lt;你不知道的JavaScript上卷&gt;&gt;","link":"/2020/04/29/JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"JavaScript中的数据类型","text":"数据类型分类JavaScript中共有8种数据类型 number bigint string boolean null undefined symbol object 数据类型简述基本数据类型number数值类型，可以表示整数或者小数。除了常规的数字外，还包括”特殊数值”：Infinity、-Infinity、NaN 123456var num1 = 1;var num2 = 1.3;alert(1/0); //Infinityalert(Infinity); //Infinityalert(\"hhh\"/1); //NaN NaN表示一个计算错误。作用是为了使得数学运算是安全的，从而脚本不会因为错误的运算而停止typeof num1; //\"number\" string字符串类型，必须放在引号中 双引号：”Flecy” 单引号： ‘Flecy’ 反引号： `Flecy`单引号双引号无区别，反引号是功能扩展引号，允许将变量和表达式包装在${…}中，然后嵌入到字符串中。 1234var name = \"Flecy\";alert(`Hi, ${name}`); // \"Hi, Flecy\"alert(`${1+2}`); //3 boolean只包含两个值：true和false 12var result = true;typeof result; //\"boolean\" null只含null一个值 12var result = null;typeof result; //\"object\" null不是一个object,null有自己的类型，它就是一个特殊值，typeof null的结果为”object”是JavaScript语言的一个错误，为了兼容性保留下来了。 undefined只含undefined一个值,undefined的含义是未被赋值。如果一个变量已经被声明，但没有赋值，那么它的值就是undefined。 12var result;typeof result; //\"undefined\" 复杂数据类型object各种值组成的集合，用于存储数据集合和更复杂的实体 12345678var blog = { name: \"弗蕾西\", domain: \"manylu.com\", owner: \"Flecy\", age: 1};typeof blog; // \"object\" 新增加的数据类型不太想把这两个数据类型放在基本数据类型中，也算是为了更好的区分JS的变化吧，所以单独把它们放在第三类中。 symbol用于创建对象的唯一标识符因为ES5的对象属性名都是字符串，为了保证每个属性的名字都是独一无二的，从根本上防止属性名的冲突，引入了symbol类型symbol值通过Symbol函数生成 12var s = symbol();typeof s; // \"symbol\" Symbol函数前不能使用new命令，否则会报错，因为生成的symbol是一个原始类型的值，不是对象。 bigint用于表示任意长度的整数，在JavaScript中，”number”类型无法代表大于2^53(或小于-2^53)的整数。通过将n添加到整数字段末尾来创建bigint类型。 12var bigInt = 123456789n;typeof bigInt; // \"bigint\" 存在兼容性问题：Firefox和Chrome已经支持bigint了，但是Safari/IE/Edge还没有 typeof运算符typeof运算符可以返回一个值的数据类型除了上面代码中返回的类型外，函数也会特别返回 123typeof alert; // \"function\"typeof []; // \"object\"typeof {}; // \"object\" JavaScript中没有一个特别的”function”类型，函数隶属于object类型，但是typeof会对函数区别对待typeof区分不了对象的细节，是数组或者是其他对象，只能确定对象的大类 typeof可以用来检查一个没有声明的变量而不会报错 123t; // Uncaught ReferenceError: t is not definedtypeof t; // \"undefined\" 参考链接 阮一峰JavaScript教程-数据类型 现代JavaScript教程-数据类型 Symbol-ES6入门","link":"/2020/04/28/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"js","slug":"js","link":"/tags/js/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"基础","slug":"前端/基础","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"}]}