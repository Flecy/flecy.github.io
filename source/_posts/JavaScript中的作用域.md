---
title: JavaScript中的作用域
toc: true
date: 2020-04-29 10:21:33
tags: js
categories:
- 前端
- 基础
---


## 作用域是什么
### 要了解一丢丢编译原理知识
尽管通常将JavaScript归类为"动态"或"解释执行"语言，但事实上它是一门编译语言。但与传统的编译语言又不同，它不是提前编译的，大部分情况下JS的编译都发生在代码执行前的几微秒(甚至更短)的时间内。

<!--more-->

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为"编译"。
- 分词/词法分析
> 这个过程会将由字符组成的字符串分解成对编程语言来说有意义的代码块，这些代码块被称为词法单元(token)。
e.g var a = 2; 会被分解为：var、a、=、;。4个词法单元

- 解析/语法分析
> 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套组成的代表了程序语法结构的树，这个树被称为"抽象语法树"(AST)。

- 代码生成
> 将AST转换为可执行的过程被称为代码生成。简单来说就是有某种方法可以将var a = 2;的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等),并将一个值存储在a中。

### 理解作用域
#### 模拟对话
学习作用域的方式是将这个过程模拟成几个人物之间的对话
登场人物：
- 引擎： 从头到尾负责整个JavaScript程序的编译及执行过程
- 编译器： 负责语法分析及代码生成等脏活累活
- 作用域： 负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

对话模拟：
> 场景：var a = 2;
	旁白：编译器首先将这段程序分解成词法单元，然后将词法单元解析为一个树结构，接下来，编译器开始进行代码生成...
	编译器：Hi，作用域，a在不在你的作用域集合里面呀？
	当前作用域(a在的话)：在呢 	
	编译器：okk,没事了
	当前作用域(a不在)：不在的		
	编译器：好滴，那麻烦你帮我声明一个叫a的变量吧，蟹蟹。
	旁白：接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a = 2这个赋值操作
	引擎：哈喽，作用域~你集合里面有没有一个叫a的变量呀？
	当前作用域(a在)：有的大哥，刚刚编译器叫我声明了变量a
	引擎：好的，我把2赋值给它
	当前作用域(a不在)：不好意思大哥，当前集合里面没有a
	引擎：没事儿，我再找找(继续询问上一级作用域)


所以变量的赋值操作会执行两个动作：
1. 首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)
2. 然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值

#### 引擎查找变量方式
编译器在编译过程中生成了代码，引擎执行它时，会通过查找变量来判断该变量是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

如果将变量比作一个盒子的话，盒子里装的东西就是变量的值,引擎会为变量进行两种类型的查找
- LHS查询：找到盒子，向里面放值
- RHS查询：取到盒子里面的值

```javascript
//小测验演示
	function foo(a) {
		var b = a;
		return a + b;
	}

	var c = foo(2);
/*
	1. foo(...) 	 RHS
	2. a = 2; 		 LHS
	3. b = a 		 LHS(b=...)、RHS(a)
	4. a + b		 RHS(a)、RHS(b)
	5. c = ...		 LHS	
*/
```

### 作用域嵌套
当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(全局作用域)为止。

```javascript
	function foo(a) {
		console.log(a + b);
	}

	var b = 2;

	foo(2); //4

//对b进行RHS查询无法在foo函数内部完成，但可以在上一级作用域(这里即为全局作用域)中完成
```

### 异常
为什么区分LHS和RHS是一件重要的事情呢？因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为是不一样的。

如果RHS查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出ReferenceError异常。
想较之下，当引擎执行LHS查询时，如果在顶层(全局作用域)中也无法找到目标变量时，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。(程序需运行在非"严格模式"下)

ES5中引入了严格模式，在严格模式下LHS查询失败的话，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常。

如果RHS查询成功了，但是你尝试对这个变量的值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎会抛出另外一种类型的异常，叫做TypeError。

ReferenceError同作用域判别失败相关。
TypeError则表示作用域判别成功了，但是对结果的操作是非法或不合理的。


## 词法作用域
作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域。另一种叫做动态作用域，仍有一些编程语言(如Bash脚本、Perl中的一些模式等)在使用。

### 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下如此)。

```javascript
function foo(a) {
	var b = a * 2;

	function bar(c) {
		console.log(a, b, c);
	}

	bar(b*3);
}

foo(2); // 2 4 12

/*
作用域气泡是由其对应的作用域代码写在哪里决定，它们是逐级包含的。这里共有三个逐级嵌套的作用域 
作用域1：包含整个全局作用域，其中只有一个标识符：foo 
作用域2：包含着foo所创建的作用域，其中有三个标识符：a、b、bar
作用域3：包含着bar所创建的作用域，其中只有一个标识符：c
*/
```

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

作用域查找会在找到第一个匹配的标识符时停止。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

### 欺骗词法
词法作用域完全由写代码期间函数所声明的位置来定义，但JavaScript也提供了两种机制用来欺骗词法作用域。

欺骗词法作用域会导致性能下降，事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。但是有关欺骗词法的机制，还是有必要了解一下的。

#### eval
JavaScript中的eval(...)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，借此来修改已经存在的词法作用域(在运行时)
```javascript
function foo(str, a) {
	eval(str); //欺骗  给人感觉var b = 3就是一直在这的
	console.log(a, b);
}

var b = 2;

foo("var b = 3", 1); //1 3
```

#### with
with本质是通过将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域(运行时)
```javascript
function foo(obj) {
	with(obj) {
		a = 2;
	}
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo(o1);
console.log(o1.a); //2

foo(o2);
console.log(o2.a); //undefined
console.log(a); //2  a被泄露到全局作用域上了

/*
代码理解
传递o1给with时，with所声明的作用域是o1,而这个作用域中已经有一个o1.a的标识符了，
LHS查询成功，所以执行a=2只是将变量a这个盒子里面的值进行改变。

传递o2给with时，with所声明的作用域是o2，进行LHS查找失败，
此为非严格模式下，所以LHS失败后，全局作用域中就会创建一个名为a的变量盒子。
*/
```

尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块作用域中，而是被添加到with所处的函数作用域中
```javascript
function foo(obj) {
	with(obj) {
		var c = 1;
		var a = 4;
		a = 2;
	}
	console.log(c);
	console.log(a);
}

var o1 = {
	a: 3
};

foo(o1);
console.log(o1.a);
/*
运行结果：
1 //c的值， var c = 1;相当于添加在with所处的函数作用域(此处即为foo作用域)中
undefined  //传递o1给with时，进行LHS查询，已有标识符o1.a存在，忽略var a = 4;声明，所以foo作用域中无变量a
2 // LHS查询成功，将o1.a中的值变为了2
*/

var o2 = {
	b: 3
};

foo(o2);
console.log(o2.a);
/*
运行结果：
1 //c的值
2  //传递o2给with时，进行LHS查询，无变量a,a被添加到foo作用域中
undefined //o2并没有a属性
*/
```

#### 性能
JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但eval(...)和with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。因此，所有的优化可能都是无意义的，代码因此性能降低，运行变慢。所以不要使用欺骗词法。

## 函数作用域和块作用域
作用域包含了一系列"气泡"，每一个都可以作为容器，其中包含了标识符(变量、函数)的定义。这些气泡互相嵌套并且整齐的排列成蜂窝型，排列的结构是在写代码时定义的。



### 函数中的作用域
函数中的作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用。

在任意代码片段外部添加包装函数，可以将内部的变量和函数定义"隐藏"起来，外部作用域就无法访问包装函数内部的任何内容，达到内容私有化效果，最小限度的暴露必要内容。
```javascript
function foo() {
	var a = 1;
	console.log(a);
}

foo(); //1 在函数内部可以访问到变量a 
console.log(a); // ReferenceError  外部访问不到变量a
```
虽然这种技术解决了一些问题(如变量私有化)，但是会导致一些额外的问题：
1. 必须声明一个具名函数foo(),foo这个名称本身就"污染"了所在的作用域
2. 必须显式的通过函数名调用这个函数才能运行其中的代码

解决方法：使用函数表达式
```javascript
(function foo() {
	var a = 1;
	console.log(a);
})(); //1 
/*
(function foo() {...})作为函数表达式意味着foo只能在...所代表的位置中被访问，外部作用域则不行。
foo变量名被隐藏在自身中意味着不会非必要的污染外部作用域
*/
```

### 块作用域
#### ES6之前
在ES6之前，JavaScript表面上是没有块级作用域这个概念的
```javascript
for(var i = 0; i < 2; i++) {
	console.log(i);
}//依次输出0 1

console.log(i);//2

/*
通常我们定义的变量i只是想要在for循环的上下文中使用
但是，使用var声明变量时，它写在哪里都是一样的，最终都会属于外部作用域(这里为全局作用域)
*/
```
但也有使用块级作用域的例子
- with：用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效
- try/catch：catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效

#### ES6之后
ES6之后，引入了新的关键字：let和const,变量声明方式变为了3种

##### var声明变量
ES6之前，变量一直使用var关键字进行变量声明

用var声明的变量，不是函数作用域就是全局作用域，没有块级作用域

var声明存在变量提升(使用var声明的变量无论在何处声明，都会被"移动"到作用域的最顶端)
```javascript
console.log(a); //undefined  按道理应该是RHS查询失败，产生ReferenceError， 但是存在变量提升，var a;被"移动"到了这行代码前
var a = 1;
```

##### let声明变量
let关键字可以将变量绑定到所在的任意作用域中(通常是{...}内部)
```javascript
for(let i = 0; i < 2; i++) {
	console.log(i);
}//依次输出0 1

console.log(i);//ReferenceError

//for循环外，变量i不可访问
```

使用let进行的声明不会在块作用域中进行提升
```javascript
if(true) {
	console.log(a); //ReferenceError
	let a = 1;
}
```

##### const声明变量
const同样可以用来创建块作用域，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误
```javascript
if(true) {
	console.log(PI); //ReferenceError  不可变量提升
	const PI = 3.14;
	PI = 4;//TypeError 不可修改
}
console.log(PI); //ReferenceError  不可外部访问
```

## 参考内容
- 《你不知道的JavaScript上卷》 第一部分